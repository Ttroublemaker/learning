# 运行环境篇

- 运行环境即浏览器（或 nodejs）
- 下载网页代码，渲染出页面，期间会执行若干 js
- 要保障代码在浏览器中：稳定且高效

### 内容

- 网页加载过程
- 性能优化
- 安全
- 错误捕获

#### 1. 网页加载过程

- 什么是 DOCTYPE 及作用
- 输入 url 到渲染出页面的整个过程
- window.onload 和 DOMContentLoaded 的区别

### 什么是 DOCTYPE 及作用

`<!DOCTYPE>` 声明位于文档中的最前面，处于 `<html>` 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档

- 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行
- 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
- DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现

#### 输入 url 到渲染出页面的整个过程

- 加载资源的形式
  - html 代码
  - 媒体文件，如图片，音视频等
  - js、css
- 加载过程
  - DNS 解析：域名->IP 地址（可能不同区域解析出不同的 IP 地址）
  - 浏览器根据 IP 地址向浏览器发起 http 请求
  - 服务器处理 http 请求，并返回给浏览器
- 渲染过程
  - 根据 HTML 代码生成 DOM Tree
  - 根据 css 代码生成 CSSOM Tree
  - 将 DOM Tree 和 CSSOM Tree 整合成 Render Tree
  - 根据 Render Tree 渲染页面
  - 遇到 script 标签则暂停渲染，优先加载并执行 js 代码，完成再继续（共用同一线程）
  - 直至把 Render Tree 渲染完成
- 重绘和回流（重排）是什么，如何避免？
  - 重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，页面重新绘制了一遍，产生重绘
  - 回流（重排）：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流
  - 注意：JS 获取 Layout 属性值（如：offsetLeft、scrollTop、getComputedStyle 等）也会引起回流。因为浏览器需要通过回流计算最新值
  - 回流必将引起重绘，而重绘不一定会引起回流
- 如何最小化重绘(repaint)和回流(reflow)
  - 需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document
  - 缓存 Layout 属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流
  - 尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）
  - 批量修改元素样式：elem.className 和 elem.style.cssText 代替`elem.style.xxx`

**思考**

- css 放在 head 标签中比 css 放在 body 标签尾部少了一次构建 RenderTree, 一次计算布局和一次渲染网页, 性能会更好; 并且 css 放在 body 标签尾部时会在网页中短暂出现"裸奔"的 HTML
- js 放 body 底部：避免阻塞渲染

#### window.onload 和 DOMContentLoaded 的区别

- window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。
- DOMContentLoaded 是 DOM 结构绘制完毕后就执行，不必等到图片、视频等加载完毕

### 2. 性能优化

- 优化原则
  - 多使用内存、缓存或其他方法
  - 减少 cpu 计算量，减少网络加载耗时
- 优化方向
  - 让加载更快
    - 减少资源体积：如压缩代码、分割代码，减少 http 请求
    - 减少访问次数，合并代码，ssr 服务端渲染，缓存（对性能优化特别重要，缓存策略 + 缓存原理）
    - 使用更快的网络：CDN 加速
  - 让渲染更快
    - css 放在 head 中，js 放在 body 最下面（防止 re-render、防止 js 阻塞）
    - 如需尽早开始执行 js，用 DOMContentLoaded 触发
    - 懒加载（图片懒加载、上滑加载更多等）
    - 对 DOM 查询进行缓存，比如 for 循环中
    - 频繁 DOM 操作，合并到一起插入 DOM 结构
    - 节流 throttle 防抖 debounce
    - 异步加载
      - 方式：动态脚本、defer、async
      - defer 延迟加载 在 HTML 解析完成后再执行，如果是多个，按照加载顺序依次执行
      - async 异步加载 在脚本加载完成后执行，如果是多个，谁先加载完成谁先执行，和加载顺序无关

**防抖 debounce**  
防抖动是将多次执行变为最后一次执行

```js
function debounce(fn, delay = 500) {
  // timer 是闭包中的
  let timer = null;
  return function () {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
      timer = null;
    }, delay);
  };
}
```

**节流 throttle**  
节流是将多次执行变成每隔一段时间执行

```js
function throttle(fn, delay = 100) {
  let timer = null;
  return function () {
    if (timer) {
      return;
    }
    timer = setTimeout(() => {
      fn.apply(this, arguments);
      timer = null;
    }, delay);
  };
}
```

### 3. 安全

常见的 web 前端攻击方式有哪些

#### XSS 跨站请求攻击

- 它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响这类攻击通常包含了 HTML 以及使用者端脚本语言
- XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。
- 如：输入可能会将 HTML 改为 `<div><script>alert(1)</script></div> `，这样面中就凭空多了一段可执行脚本

**如何防御**
![xss攻击](./imgs/http/xss攻击.png)

#### XSRF 跨站请求伪造

![XSRF跨站请求伪造](./imgs/http/XSRF攻击.png)

**如何防御**

- 使用 post 接口
- 增加验证,例如密码、短信验证码，指纹等

### 错误捕获

- 错误分类
  - 即时运行错误 + 资源加载错误
- 捕获方式
  - 即时运行错误：try...catch...,window.onerror
  - 资源加载错误：
    - object.onerror
    - performance.getEntries()
      > 获取到加载成功的资源集合，通过标签获取所有资源集合，可以间接筛选出未成功加载的集合
    - Error 事件捕获（注意：捕获阶段可以捕获到，冒泡阶段捕获不到）
    ```js
    window.addEventListener("error", (err) => {
      console.log(err);
    });
    ```
- 跨域的 js 运行错误可以捕获吗，错误提示是什么，应该如何处理

  - 可以捕获，但是没办法获取错误信息，只有"Script error."错误提示
  - 解决办法：
    - 1：在 script 标签上加 crossorigin 属性
    - 2：设置 js 资源响应头 Access-Control-Allow-Originl:"\*"

- 错误上报
  - 通过 Ajax 通信的方式上报（极少）
  - 使用 Image 对象上报（常用）
  ```js
  const image = new Image()
  <!-- 可以携带任何信息 -->
  image.src="http:baidu.com?error='xxxxxxxx'"
  ```

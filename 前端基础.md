# 前端基础

> ## 节流和防抖

防抖 debounce：指在事件触发 n 秒后再执行回调，如果在 n 秒内再次被触发，则重新计算时间，限制执行频率，有节奏的执行

1. 非立即执行版：触发事件后函数不会立即执行，而是在 停止触发行为 n 秒 后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
2. 立即执行版：触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。

主要应用场景有：

- a、scroll 事件滚动触发，
- b、搜索框输入查询
- c、表单验证
- d、按钮提交事件
- e、浏览器窗口缩放，resize 事件

节流 throttle：指如果持续触发某个事件，则每隔 n 秒执行一次，限制执行次数，多次密集的触发只执行一次

主要应用场景：

- a、DOM 元素的拖拽功能实现
- b、射击游戏类
- c、计算鼠标移动的距离
- d、监听 scroll 事件

【节流关注过程，防抖关注结果】

```js
function debounce(fn, delay = 200) {
  let timer = 0;
  return function () {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, arguments); // 透传 this 和参数
      timer = 0;
    }, delay);
  };
}
const input1 = document.getElementById("input1");
input1.addEventListener(
  "keyup",
  debounce(() => {
    console.log("发起搜索", input1.value);
  }),
  300
);

function throttle(fn, delay = 100) {
  let timer = 0;
  return function () {
    if (timer) return;
    timer = setTimeout(() => {
      fn.apply(this, arguments);
      timer = 0;
    }, delay);
  };
}
const div1 = document.getElementById("div1");
div1.addEventListener(
  "drag",
  throttle((e) => {
    console.log("鼠标的位置", e.offsetX, e.offsetY);
  })
);
```

---

> ## px、%、em、rem、vw/vh 有什么区别

- px：基本单位，绝对单位
- %：相对于父元素的百分比
- em：相对于当前元素的 font-size
- rem：相对于根结点的 font-size
- vw/vh：屏幕宽度/高度的 1%，vmin 两者的最小值，vmax 两者的最大值

---

> ## 箭头函数

注意箭头函数和普通函数的区别

在普通函数中，this 指向运行时的作用域，即 this 的指向可以随着函数运行时作用域的不同而可能产生不同的指向

而箭头函数的 this 指向定义时的作用域，不会改变

箭头函数有什么缺点：

- 没有 arguments
- 无法通过 bind、apply、call 改变 this 指向=> 因为箭头函数没有自己的 this
- 无法作为构造函数

什么时候不能使用箭头函数：

- 对象方法
- 原型方法
- 构造函数
- 动态上下文中的回调函数

```js
const obj = { name: "xxx" };

obj.__proto__.getName = () => {
  // this 指向 window
  return this.name;
};

btn.addEventListener("click", () => {
  // this 指向 window
});
```

- vue 生命周期和 method（vue 组件本质是对象，同 a），react 可以，因为 react 组件（非 hook）本质是类

---

> ## 描述 TCP 三次握手与四次挥手

建立 TCP 连接 :

先建立连接（确保双方都有收发消息的能力）；
再传输内容（如发送一个 get 请求）；
网络连接是 TCP 协议，传输内容是 HTTP 协议

三次握手：建立连接

- client 发包，server 接收，server：有 client 要找我
- server 发包，client 接收，client：server 已经收到消息了
- client 发包，server 接收，server：client 要准备发送了

四次挥手：关闭连接

- client 发包，server 接收，server：client 已请求结束
- server 发包，client 接收，client：server 已收到，我等待它关闭
- server 发包，client 接收，client：server 此时可以关闭连接了
- client 发包，server 接收，server：可以关闭了，然后关闭连接

---

> ## for … in 和 for…of 有什么区别

- for … in 遍历得到 key，for…of 遍历得到 value
- 适用于不同的数据类型，

  - 遍历数组：in 可以，of 可以
  - 遍历对象： in 可以，of 不可以
  - 遍历 Map、Set： in 不可以，of 可以
  - 遍历 generator： in 不可以，of 可以

- 可枚举 vs 可迭代
  - for…in 用于可枚举数据：如数组、字符串、对象，得到 key
  - for…of 用于可迭代数据：如数组、Map、Set、generator, 有[Symbol.iterator]属性，得到 value

扩展:
for await … of 有什么作用：用于遍历多个 promise

---

> ## offsetHeight/offsetWidth、scrollHeight/scrollWidth、clientHeight/clientWidth 的区别

- offsetHeight/offsetWidth：border + padding + content
- clientHeight/clientWidth: padding + content
- scrollHeight/scrollWidth: padding + 实际内容尺寸

---

> ## HTMLCollection 和 NodeList 有什么区别

- dom 树中的所有节点都是 Node，包含 Element、Comment、Text 等节点
- HTMLCollection 是 Element 的集合
- NodeList 是 Node 的集合
- elem.childNodes or elem.children

扩展：都是类数组，转换成数组：Array.form(arr)、 […arr]

类数组和数组有啥区别：

- 都有 length 属性
- 类数组也可以 for 循环遍历，有的类数组还可以通过 for of 遍历
- 类数组不具备数组的原型方法，因此类数组不可调用相关数组方法（如，push,slicec,concat 等等）

常见的类数组有：

- 函数的参数 arguments
- 通过 getElementsByTagName/getElementsByClassName/getElementsByName 等方法获取的 dom 列表（也叫 HTMLCollection）
- 通过 querySelectorAll()方法获取的 NodeList 节点列表

---

> ## js 严格模式有什么优势

严格模式特点：

- 全局变量必须先声明
- 禁止使用 with
- 创建 eval 作用域
- 禁止 this 指向 window
- 函数参数不能重名

---

> ## 跨域请求时为何会发送 options 请求

cors 由一系列 HTTP 相应头组成，这些 HTTP 响应头决定了浏览器是否阻止前端 js 代码跨域获取资源，是浏览器拦截

1.  CORS 主要在服务器端进行配置，客户端浏览器无需做额外配置，即可请求开启了 CORS 的接口

2.  CORS 在浏览器中有兼容性问题，只有支持 XMLHttpRequest level2 的浏览器才能正常使用：
    `js Access-Control-Allow-Origin: <origin> | * `

3.  cors 请求的分类
    根据请求方式和请求头的不同，可以将 cors 请求分为以下两类：

    1.  简单请求
        - 1.1 同时满足以下条件：
          - 1.1.1 请求方式为 GET、POST、HEAD 三者之一
          - 1.1.2 请求头中不超过以下几种字段：无自定义头部字段、Accept, Accept-Language, Content-Language, DPR, Downlink, Save-Data, Viewport-Width, Width, Content-Type(值仅限于 text/plain、application/x-www-form-urlencoded、multipart/form-data 三者之一)
    2.  预检请求
        - 2.1 只要符合以下任何一个条件的请求，都需要进行预检请求：
          - 2.1.1 请求方式为 GET、POST、HEAD 之外的请求
          - 2.1.2 请求头包含自定义头部字段
          - 2.1.3 向服务器发送了 application/json 格式的数据

在浏览器与服务正式通信之前，浏览器会先发送 OPTIONS 请求，用于检测服务器是否允许该实际请求
服务器成功响应预检请求后，才会发送真正的请求，并携带真实数据

简单请求和预检请求区别

- 简单请求：只会发生一次请求
- 预检请求：两次请求
